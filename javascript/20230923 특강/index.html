<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    /**
     * 왜 객체지향 프로그래밍을 해야할까? 
     * 1. 깔끔하고 이해하기 쉬운 코드를 짤 수 있다.
     * 2. 확장하기 쉬운 코드를 짤 수 있다.
     * 3. 유지보수 하기 쉬운 코드를 짤 수 있다.
     * 4. 메모리를 절약하는 코드를 짤 수 있다.
     **/

    // 절차지향 프로그래밍
    //  let name = 'Knight',
    //  weapon = 'Sword';

    //  function attack(){
    //   return `${name}이 ${weapon}으로 공격합니다.`
    //  }

    //  function changeWeapon(){
    //   weapon = 'Spear';
    //   return  `무기가 ${weapon}으로 교체되었습니다.`
    //  }

    // 객체지향 프로그래밍
    // const knight = {
    //   name : 'solo',
    //   weapon : 'm16',
    //   attack(){
    //     return `${this.name}가 ${this.weapon}으로 공격합니다.`
    //   },
    //   changeWeapon(newWeapon){
    //     this.weapon = newWeapon;
    //     return `무기가 ${this.weapon}으로 교체되었습니다.`;
    //   }
    // };

    // encapsulation ===> 캡슐화 한다.
    // 데이터와 데이터를 조작하는 메서드들을 하나의 단위로 묶는것!
    // 위와 같은 방법은 두가지 문제가 있다.
    // 1. 객체가 필요할 때마다 새롭게 선언한다.
    // 2. 똑같은 기능을 하는 함수가 반복되고 있다.

    // 생성자함수와 프로토타입 사용
    // function Knight(name, weapon){
    //   this.name = "solo",
    //   this.weapon = "Sword"
    // };

    // Knight.prototype.attack = function () {
    //   return `${this.name}가 ${this.weapon}으로 공격합니다.`
    // }
    // // 모든 인스터스와 동일한 메서드를 공유한다.
    // // 객체마다 함수생성을 할 필요가 없다.

    // Knight.prototype.changeWeapon = function (newWeapon) {
    //   this.weapon = newWeapon;
    //   return `무기가 ${this.weapon}으로 교체되었습니다.`
    // };

    // class 문법
    class BaseCharacter{
      constructor(name, weapon) {
        this.name = name;
        this.weapon = weapon;
      }

      attack() {
        return `${this.name}가 ${this.weapon}으로 공격합니다.`
      }

      changeWeapon(newWeapon) {
        this.weapon = newWeapon;
        return `무기가 ${this.weapon}으로 교체되었습니다.`
      }
    }

    // const knight = new Knight('sole', '검');

    // class로 상속 받기쉬워짐

    // 상속

    class Skeleton extends BaseCharacter {
      // constructor(name, weapon, unitType){
      //   super(name, weapon); // 부모 클래스의 생성자 호출
      //   this.unitType = unitType;
      // }
    }
    
    const skeleton = new Skeleton("호드", "방패", "강철");

  </script>
</body>
</html>